var fs = require('fs');
var crypto = require('crypto');
var mkdirp = require('mkdirp');
var moment = require('moment');

function getUserHome() {
  return process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];
}

function extend(extension, obj) {
  for (var key in extension) {
    obj[key] = extension[key];
  }
  return obj;
}

function Cache(opts) {

  var defaults = {
    path: getUserHome() + '/.cache/',
    ext: '.json'
  };

  function init() {
    if (!fs.existsSync(this.opts.path)) {
      mkdirp(this.opts.path, function(err) {
        if (err) {
          console.error(err);
        }
      });
    }
  }
  this.opts = extend(opts, defaults);
  init.call(this);
}

Cache.prototype.filePath = function(key) {
  return this.opts.path + this.getHash(key) + this.opts.ext;
};

Cache.prototype.flush = function(key) {
  fs.unlink(this.filePath(key), function(err) {
    console.log(err);
  });
};

Cache.prototype.getHash = function(key) {
  return crypto.createHash('md5').update(key).digest('hex');
};

Cache.prototype.get = function(key) {
  var filePath = this.filePath(key);
  if (!fs.existsSync(filePath)) {
    return false;
  }
  var content = JSON.parse(fs.readFileSync(filePath).toString());
  var stats = fs.statSync(filePath);
  var now = moment().format('X');
  var expiry = moment(stats.mtime).add('milliseconds', content.ttl).format('X');
  if (now > expiry) {
    this.flush(key);
    return false;
  } else {
    return content.value;
  }
};

Cache.prototype.set = function(key, value, ttl) {
  var filePath = this.filePath(key);
  var content = {
    key: key,
    value: value,
    ttl: ttl
  };
  fs.writeFileSync(filePath, JSON.stringify(content));
};

module.exports = Cache;
